#include "page/ir/ir_raw_helper.h"
#include "utils/file.h"

#include <ctype.h>
#include <stdlib.h>
#include <string.h>

/*
 * IR raw helpers used by ir_controller_learn_button().
 *
 * Source of truth for this logic:
 * - README section "IR: cómo se guardan y se envían señales" (raw capture/send)
 *
 * - `man ir-ctl` and `ir-ctl --help` (capture/send behavior and raw mode usage)
 * - LIRC raw timing conventions (+pulse / -space sequences)
 * - Inspecting real captures generated by:
 *   `ir-ctl -r -d <rx_dev> > sample.raw`
 *   then parsing token format and sequence properties empirically
 * - Existing runtime constraints of this app (minimum token threshold, retry flow)
 *
 * Example of expected raw timing text (ir-ctl capture output):
 *   +9000 -4500 +560 -560 +560 -1690
 *   +560 -560 +560 -560 +560 -560
 *
 * Why this module exists:
 * - Keep IR learn-domain logic out of ir_service (service stays hardware/I/O).
 * - Make validation/repair reusable and easier to test.
 */


 /*
 * Why 160:
 * - Empirical threshold to reject very short/noisy captures.
 * - Real remote frames captured in this project are typically well above this.
 * - Reduces false positives from accidental or partial reads.
 */
#define IR_RAW_MIN_TOKENS 160

/*
 * Validate a raw capture file produced by ir-ctl.
 *
 * Expected token format: (+|-)<positive_integer> separated by whitespace.
 * Example: "+9000 -4500 +560 -560 ..."
 *
 * Current acceptance rules:
 * - File must be non-empty and parseable.
 * - First token must start with '+' (pulse/mark first is the expected pattern
 *   for LIRC-style timing sequences captured from typical IR remotes).
 * - Must contain at least IR_RAW_MIN_TOKENS timing values.
 *
 * Outputs:
 * - token_count_out: total parsed tokens.
 * - last_sign_out: sign of the last token (+1 or -1), used by repair flow.
 */
int ir_validate_raw_capture_file(const char *raw_path, int *token_count_out, int *last_sign_out)
{
    long sz = 0;
    int token_count = 0;
    int first_sign = 0;
    int last_sign = 0;
    char *buf = read_file_as_buffer(raw_path, &sz);
    char *p = NULL;

    if (token_count_out)
        *token_count_out = 0;
    if (last_sign_out)
        *last_sign_out = 0;

    if (!buf || sz <= 0)
    {
        free(buf);
        return 0;
    }

    p = buf;
    while (*p) 
    {
        char *end = NULL;
        long value = 0;
        int sign = 0;

        while (*p == ' ' || *p == '\n' || *p == '\t' || *p == '\r')
            p++;
        if (*p == '\0')
            break;

        if (*p != '+' && *p != '-') {
            free(buf);
            return 0;
        }

        sign = (*p == '+') ? 1 : -1;
        last_sign = sign;
        if (token_count == 0)
            first_sign = sign;
        p++;

        if (*p < '0' || *p > '9') {
            free(buf);
            return 0;
        }

        value = strtol(p, &end, 10);
        if (end == p || value <= 0) {
            free(buf);
            return 0;
        }

        token_count++;
        p = end;
    }

    free(buf);

    if (token_count_out)
        *token_count_out = token_count;
    if (last_sign_out)
        *last_sign_out = last_sign;

    if (token_count < IR_RAW_MIN_TOKENS)
        return 0;
    if (first_sign != 1)
        return 0;

    return 1;
}

/*
 * Try to repair an odd raw capture by appending a synthetic trailing gap.
 *
 * Rationale:
 * Some captures end with a pulse ('+') and odd token count; adding a final
 * gap can make the sequence structurally valid for downstream usage.
 *
 * Preconditions:
 * - token_count >= IR_RAW_MIN_TOKENS
 * - token_count is odd
 * - last_sign is '+'
 *
 * Returns 1 on successful rewrite, 0 otherwise.
 */
int ir_append_synthetic_gap_for_odd_capture(const char *raw_path, int token_count, int last_sign)
{
    const char *gap = " -20000\n";
    char *buf = NULL;
    char *patched = NULL;
    long sz = 0;
    size_t gap_len = strlen(gap);
    size_t trimmed_len = 0;
    int rc = 0;

    if (!raw_path || raw_path[0] == '\0')
        return 0;
    if (token_count < IR_RAW_MIN_TOKENS || (token_count % 2) == 0 || last_sign <= 0)
        return 0;

    buf = read_file_as_buffer(raw_path, &sz);
    if (!buf || sz <= 0) {
        free(buf);
        return 0;
    }

    trimmed_len = (size_t)sz;
    while (trimmed_len > 0 && isspace((unsigned char)buf[trimmed_len - 1]))
        trimmed_len--;

    patched = (char *)malloc(trimmed_len + gap_len + 1);
    if (!patched) {
        free(buf);
        return 0;
    }

    memcpy(patched, buf, trimmed_len);
    memcpy(patched + trimmed_len, gap, gap_len);
    patched[trimmed_len + gap_len] = '\0';

    rc = write_entire_file(raw_path, patched, trimmed_len + gap_len);

    free(patched);
    free(buf);

    return rc == 0;
}
